---
title: 最佳实践
date: 2023-04-23 13:54:40
permalink: /pages/52d5c3
article: false
---

::: warning
`ONLY_LOCAL` 本地重试基于内存重试，重试次数和间隔时间不宜太长，防止接口超时或流程阻塞
:::

## 场景一 <Badge text="强通知性" />

::: theorem 强通知性
在某些业务场景下，需要强制保证将通知、消息等数据发送到目标端接口，但由于网络的不确定性以及目标系统、应用、服务的不确定性，可能会造成通知消息的发送失败。
此类场景下可以使用`LOCAL_REMOTE`模式进行重试。

比如: 发送MQ消息失败、回调通知第三方失败 ...
:::

## 场景二  <Badge text="短暂性"/>

::: theorem  短暂性
在系统的运行环境中，不可避免的依赖各种服务，由于依赖服务出现短暂性不可用或者因网络波动造成瞬间闪断。可以使用`ONLY_LOCAL`或者`LOCAL_REMOTE`进行重试
:::

## 场景三 <Badge text="持久化数据"/>

::: theorem 持久化数据
在微服务架构下很难保障数据的强一致性，绝大多数场景都是保障最终一致性; 可能存在系统依赖的某些外部数据由于网络或者其他原因还未准备好，就发起了业务处理导致系统发生异常;
可能不久外部系统数据准备完成，就会导致该系统丢失大量业务数据。此场景可以使用`LOCAL_REMOTE`进行重试
:::

## 场景四 <Badge text="流量管控"/>

::: theorem 流量管控
重试并不是我们想象的写个for重复调用几次就可以了，重试产生的放大效应危害也是巨大的,[有兴趣可以看看重试的风险](https://juejin.cn/post/6914091859463634951#heading-6) 
重试流量的管控也是Easy Retry核心能力之一; 
- 单机链路管控
- 限制链路重试
- 结合DDL控制无效重试
- 支持多种退避策略
- 支持可视化配置 [预览站点 admin/admin](http://preview.easyretry.com/#/basic-config-list)
:::

## 未完待续..... <Badge text="帮助我们改善此页面" />

## [帮助我们改善此页面](https://gitee.com/aizuda/easy-retry-docs/blob/master/docs/01.%E6%8C%87%E5%8D%97/01.%E6%8C%87%E5%8D%97/03.%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.md)
