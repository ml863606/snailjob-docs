---
title: 使用说明
date: 2023-07-11 18:37:16
permalink: /pages/cfd232/
---

# EasyRetry适用于哪些场景
## 强通知性
::: theorem 强通知性
在某些业务场景下，需要强制保证将通知、消息等数据发送到目标端接口，但由于网络的不确定性以及目标系统、应用、服务的不确定性，可能会造成通知消息的发送失败。
此类场景下可以使用`LOCAL_REMOTE`模式进行重试。

比如: 发送MQ消息失败、回调通知第三方失败 ...
:::

## 短暂性
::: theorem  短暂性
在系统的运行环境中，不可避免的依赖各种服务，由于依赖服务出现短暂性不可用或者因网络波动造成瞬间闪断。可以使用`ONLY_LOCAL`或者`LOCAL_REMOTE`进行重试
:::

## 持久化数据
::: theorem 持久化数据
在微服务架构下很难保障数据的强一致性，绝大多数场景都是保障最终一致性; 可能存在系统依赖的某些外部数据由于网络或者其他原因还未准备好，就发起了业务处理导致系统发生异常;
可能不久外部系统数据准备完成，就会导致该系统丢失大量业务数据。此场景可以使用`LOCAL_REMOTE`进行重试
:::

## 流量管控
::: theorem 流量管控
重试并不是我们想象的写个for重复调用几次就可以了，重试产生的放大效应危害也是巨大的,[有兴趣可以看看重试的风险](https://juejin.cn/post/6914091859463634951#heading-6)
重试流量的管控也是Easy Retry核心能力之一;
- 单机链路管控
- 限制链路重试
- 结合DDL控制无效重试
- 支持多种退避策略
- 支持可视化配置 [预览站点 admin/admin](http://preview.easyretry.com/#/basic-config-list)
- 支持动态关闭重试场景
- [更多能力](https://www.easyretry.com/pages/a2f161/)
  :::

# EasyRetry不适用于哪些场景
## 接口调用需要同步返回结果
需要立刻返回结果的，建议使用`ONLY_LOCAL`且次数不应该太多，防止接口超时

## 非异常的重试任务
使用任务表的模式不建议使用EasyRetry, 比如常见的付款任务、结算任务等

