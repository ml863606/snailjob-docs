---
title: 场景应用
date: 2023-07-06 19:02:54
permalink: /pages/406a68/
---

## 强通知场景

::: theorem 强通知性
在某些业务场景下，需要强制保证将通知、消息等数据发送到目标端接口，但由于网络的不确定性以及目标系统、应用、服务的不确定性，可能会造成通知消息的发送失败。
此类场景下可以使用`LOCAL_REMOTE`或者`ONLY_REMOTE`模式进行重试。
:::
### 发送MQ场景
众所周知消息队列的异步、削峰、解耦优点, 在业务系统承担着十分重要的角色，如果保障消息的可达性就尤为重要了。
下面模拟一个常见的的下单流程。
<img :src="$withBase('/img/强达性_MQ1.png')" class="no-zoom" style="zoom: 100%;">
订单中心下单完成后回抛出下单成功消息从而解耦了订单和其他业务系统的耦合关系，其他相关的业务系统只需要监听订单的下单成功的消息即可完成自己的业务逻辑。
但是若由于网络的不稳定、消息队列故障等等，可能导致消息未发送出去，这时候就需要增加重试流程来保障消息的强可达性。

<img :src="$withBase('/img/强达性_MQ2.png')" class="no-zoom" style="zoom: 100%;">
然后接入EasyRetry后将变的非常简单，您只需要简单的一个注解就保障强可达性。

```java
@Retryable(scene = "create-order-success", retryStrategy = RetryType.ONLY_REMOTE)
public void sendCreateOrderSuccessMessage(Message message) {
    ......
    
    // 发送消息
    mqProducer.publish("主题", "key", message);
}
```
如果您不想使用注解的方式您可是使用手动模式
```java
public void createOrder(Order order) {

    // 其他逻辑
    // 发送消息
    
    try {
        mqProducer.publish("主题", "key", order);
    } catch (Exception e) {
        // 发送出现异常
        EasyRetryTemplate retryTemplate = RetryTaskTemplateBuilder.newBuilder()
          .withExecutorMethod(RetrySendMqMessageExecutorMethod.class)
          .withParam(order)
          .withScene(RetrySendMqMessageExecutorMethod.SCENE)
          .build();
        retryTemplate.executeRetry();
    }
}
```

```java
@ExecutorMethodRegister(scene = RetrySendMqMessageExecutorMethod.SCENE, async = true, forceReport = true)
public class RetrySendMqMessageExecutorMethod implements ExecutorMethod {

    public static final String SCENE = "retrySendMqMessageExecutorMethod";

    @Override
    public Object doExecute(Object objs) {
        Object[] params = (Object[]) objs;
        // 发送消息
        mqProducer.publish("主题", "key", params[0]);
        return null;
    }
}    

```

### 回调场景


